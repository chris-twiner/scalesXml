
The 0.6.0 release removes support for scala versions below 2.11, migrates to scalaz-iteratees and adds support for 2.13's new collection approach.

Build wise it's moved to maven and github actions to simplify rolling out any future fixes, similarly the docs have migrated from the home-brew site builder to mkdocs.  The feature scope is: 

1. #51 - Migration from the old IterV to the newer Scalaz iteratee library
2. #52 - Scala 2.13 support

## Scalaz Iteratee

The pull api (and async pull api) has changed to be fully monadic and will require code changes, the default Id implementation is not tail recursive and leads to SOEs.  Direct usage of iteratee's largely involves swapping Cont and Done for cont and done and migrating enumeratee / run usage to:

```scala
(iteratee &= iteratorEnumerator(pull.it)) run
```

instead of

```scala
iteratee(pull.it) run
```

this is because enumerators are no longer implicitly bound, things are notably more verbose.  Scalaz now provides a good selection of useful starting enumerators.

Iteratee[E,A] is a type alias for Iteratee[E,Id,A] so everything is "wrapped" in an Id container (Id[X]=X), as such you may need to specify an appropriate Monad type to get a proper compilation and run, e.g. IO or Trampoline.  Indeed, if the compiler doesn't present an error it's typically derived as Id, which can SOE.

To aid in this, and type-inference given a specific monad, the following helper function and defaults are provided:

```scala
def iterateesOf[F[_]]: IterateeFunctions[F]

val ioIteratees = iterateesOf[IO]
val trampolineIteratees = iterateesOf[Trampoline]
// not recommended but may help migrations
val idIteratees = iterateesOf[Id]

``` 

The functions in IterateeFunctions already have F captured with the type TheF (although F is not stored as an implicit given conflicts with import Scalaz._). So using:

```scala
import scales.utils._
import scales.utils.trampolineIteratee._
```

will bring in shadowing functions already defined within Trampoline, allowing better type inference.

### Upgrading to Monadic usage

IterV would allow non-monadic usage with tail recursion, this is no longer directly possible in Scalaz 7 IterateeT usage.  A "great" example of this is the foldOnDone method implementation, the original IterV based code is fairly simple:

````scala

    var currentI = initResumable(it).eval
    var isdone = isDone(currentI)
    var currentA = initAcc
    while( !isdone || (isdone && !isEOF(currentI)) ) {

      if (isdone) {
        val a = extract(currentI)
        if (!a.isDefined)
          return currentA
        else {
          currentA = f(currentA, a.get)
          currentI = extractCont(currentI)
        }
      }

      currentI = currentI(it).eval
      isdone = isDone(currentI)
    }
    currentA
````

i.e. keep extracting the next continuation and call the f fold function when you find a done.  The code runs fast (400ms on the dev box) and in constant space, as you'd expect.  An "obvious" translation to a monadic version is:

```scala
val starter = (initResumable &= e).eval

val r =
  (foldIM[ACC,F,(ACC, ResumableIter[E,F,A], Boolean)]((p, a) => {
    val (currentA, itr, _) = a
    for {
      isdone <- isDone(itr)
      iseof <- isEOF(itr)

      res <-
        if (isdone && !iseof) {
          val a = extract(itr)
          F.map(a) { a =>
            if (!a.isDefined)
              (currentA, itr, true)
            else
              (f(currentA, a.get), extractCont(itr), false)
          }
        } else
           F.point((currentA, itr, true))
    } yield {
      val (currentA, itr, done) = res

      (currentA, (itr &= e).eval, done)
    }
  })(init = (initAcc, starter, false), stopOn = a => a._3) &= repeat[ACC,F](initAcc) ) run

F.map( r ) { r =>
  val ((acc, nr, b), cont) = r
  acc
}
```

We have to loop, so we use a fold with an early exit and drive it through a never ending enumerator (whose value "p" above is ignored), unlike foldI, foldIM expects an accumulator wrapped in the monad.  As we are looping we cannot return and have to handle all exit criteria directly, so more "if" branches are introduced.

Finally, as we must stay in the monad there is lots of direct map/point and of course the hidden bind/flatmaps.  This code runs *very* slowly - 20 seconds (on the dev box), we've gone from a non-monadic version at 400ms to 20s, why?

[This SO post](https://stackoverflow.com/a/41128527/1028537) does an excellent job of explaining how seemingly innocuous and correct code can become a very large chain of O(N) calls under the hood.  This version of "r" brings us back to the 400-450ms mark (still a bit slower but no SOEs and monadic):

```scala
val r =
  (foldIM[ACC,F,(ACC, ResumableIter[E,F,A], Boolean)]((p, a) => {
    val (currentA, itr, _) = a
    for {
      step <- itr.value
      isdone = isDoneS(step)
      iseof = isEOFS(step)

      shouldStop = (currentA, itr, true)

      res =
        if (isdone && !iseof) {
          val a = extractS(step)
          if (a.isEmpty)
            shouldStop
          else
            (f(currentA, a.get), extractContS(step), false)
        } else
          shouldStop

    } yield {
      val (currentA, itr, done) = res

      (currentA, (itr &= e).eval, done)
    }
  })(init = (initAcc, starter, false), stopOn = a => a._3) &= repeat[ACC,F](initAcc) ) run
```

Here, instead of 2 flatmaps and 1 flatmap containing a map that is also mapped we are left with only one flatmap - that of the underlying step.  To enable this there are now new functions ending in S designed to behave like the old IterV based function and stay out of monads.  If your code runs slower than expected this is a likely culprit. 

Per the above example you can use foldIM with a repeating enum and a stopOn clause, or if you know the range of times you wish to repeat you can use the Scalaz foldM and a fixed enumerator (e.g. iteratorEnumerator)

### BEWARE THE ITERATOR

As Trampolining is now used anything that generates with side effects e.g. Iterator[PullType] can case significant oddities as one part of the code you'd reasoned is finished starts up again and calls next.

In order to aid this there is a memory and state trade off to be had and wrapping the iterator in EphemeralStream.  To aid this three functions are introduced:

```scala
package scales.utils.iteratee

object EphemeralStreamEnum {
  def enumEphemeralStream[E, F[_] : Monad](xs: EphemeralStream[E]): EnumeratorT[E, F]

  def enumEphemeralStreamF[E, F[_] : Monad](state: EphemeralStream[E] => Unit)(xs: EphemeralStream[E]): EnumeratorT[E, F]

  def toEphemeral[A](iterator: Iterator[A]): EphemeralStream[A]
}
```

toEphemeral safely wraps an iterator in EphemeralStream ensuring trampolining does not trigger more .next calls.

The enumEphemeralStreamF variant lets you use a workaround to keep the progress and restart processing the stream:

```scala
var theStream: EphemeralStream[PullType] = toEphemeral(xmlpull: Iterator[PullType])
val func = (e: EphemeralStream[PullType]) => {iter = e}

def enum(e: EphemeralStream[PullType]) = enumEphemeralStreamF[PullType, TheF](func)(e)

val starter = (ionDone &= enum(theStream)).eval

// some time later, restart the stream processing
(extractCont(starter) &= enum(theStream)).eval
```

!!! Note "Consider iteratee composition"
    If you are using iteratee's already consider composing them via for and only processing the stream once (i.e. not using extractCont) if intermediate values aren't needed.

## Scala 2.13 support

2.13 re-worked much of the internal collection logic, including CanBuildFrom.  Scales required the ability to swap out the actual container used for Tree's in order to reduce allocation cost (yielding better performance).

As such there is a compatibility layer working around most of this unpleasantness, however for compatibility CanBuildfrom is still implicitly required in the apis.

None of this should affect 2.13 usage but please raise an issue should you find one.